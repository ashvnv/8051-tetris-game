;====================================
;	8051 TETRIS GAME
;	AUTHOR: ASHWIN VALLABAN
;	https://ashvnv.github.io/ashvnv/
;====================================

;====================================================================================
;	MIT License
;
;	Copyright (c) 2024 Ashwin Vallaban
;
;	Permission is hereby granted, free of charge, to any person obtaining a copy
;	of this software and associated documentation files (the "Software"), to deal
;	in the Software without restriction, including without limitation the rights
;	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;	copies of the Software, and to permit persons to whom the Software is
;	furnished to do so, subject to the following conditions:
;
;	The above copyright notice and this permission notice shall be included in all
;	copies or substantial portions of the Software.
;
;	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;	SOFTWARE.
;====================================================================================

; ALGORITHM IS MODULAR
;	PART 1: DISPLAY. READ THE REGISTERS AND DISPLAY ALL THE VALUES
;	PART 2: WHEN TIMER INTERRUPT OCCURS, MAKE A DOWN MOVEMENT AND UPDATE REGISTERS
;	PART 3: WHEN SWITCH STATE IS READ, MAKE LEFT, RIGHT, CLK, ANTICLK OR DOWN MOVEMENT


;############## PORTS ASSIGNED #################
;PORT0 AND PORT1 FOR DRIVING THE DISPLAY

;INT0 FOR PCF8574A INTERRUPT
;P3.6 FOR SCL
SCL EQU P3.6
;P3.7 FOR SDA
SDA EQU P3.7
	
;***************************************
;PORTS USED FOR SENDING DATA TO 4094 IC
;***************************************
DAT EQU P2.0
CLK EQU P2.1
	
DISP_CLK EQU P3.5
	
CLR_SCORE EQU P2.2 ; HIGH PULSE WILL CLEAR THE 7 SEGMENTS

;############## REGISTERS USED #################
;!!!!!!!!!!!!!!!!!! USED IN ISR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;0x6F to 0x7E IS TO BE SHOWN ON THE DISPLAY

;0x3C STORING R1 POINTER VALUE FOR PRESERVING ISR

;0x3E FOR BACKING UP R1 AFTER ISR IS INITIATED

;0x25.0 IS USED IN DISPLAY SUBROUTINE. IF CLR THEN STAGE 1 EXECUTED AFTER INTERRUPT IS SERVICES ELSE STAGE 2
;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;7FH TO 75H FOR STORING DISPLAY VALUES
;20H & 21H FOR STORING CURRENT SHAPE VALUE
;0H AND 1H FOR POINTERS
;2H STORES THE 0s COUNT
;7H AND 6H ARE THE COUNTERS
;R5 STORES THE TIMER1 OVERFLOW COUNTER

;SCORES ARE STORED IN 0x43
;EACH SHAPE HAS NUMBER OF 0s WHICH ARE COUNTED. PLAYER WHO CAN 
;	FIT THE MOST NUMBER OF SHAPES IN THE DISPLAY WINS


;F0 FLAG INDICATED START OF THE SCAN IF SET AND SEND OF THE SCAN IF 0
;26.0 FOR LEFT MOVEMENT
;26.1 FOR RIGHT MOVEMENT
;26.2 FOR CLK MOVEMENT
;26.3 FOR ANTI CLK MOVEMENT
;26.4 FOR INDICATING IF CANCEL OPERATION PERFORMED
;26.5 FOR INDICATING IF SWITCH STATE CHANGED
;26.6 IF SET THEN ENABLE HIGH SPEED FALL TIME OF SHAPES

;26.7 RESTART THE GAME

;TWO SCORING METHODS AVAILABLE.
;ONE IS TO COUNT THE 0s IN THE SHAPE DISPLAY ON 7 SEGMENT
;SECOND IS TO CHECK IF A ROW IS FULL. IF YES THEN SHIFT ROWS BY ONE AND GIVE A POINT
;SET 0x23.0 INDICATES TO USE THE SECOND METHOD


SHP_SRT_LOC EQU 0x04
SHP_BIT_LOC EQU 0x03
	
SHP_COUNT EQU 0x24
	
COUNT_BACKUP EQU 0x37


;######### Configure Interrupt Service Routine ########
ORG 0000H
	LJMP START

ORG 0003H ;IE0 INTERRUPT (PIN INT0) INT0 LEFT MOVEMENT
	SETB 0x26.5
	;SET SWITCH STATE CHANGED FLAG
	RETI


ORG 000BH ;TIMER0 OVERFLOW COUNTER
	;USING 16BIT TIMER
	INC R5; INCREMENT THE OVERFLOW COUNTER
	RETI
	
ORG 0013H ;IE1 INTERRUPT (PIN INT1) RESTART THE GAME TRIGGER
	SETB 0x26.7 ;SET THE RESET FLAG
	RETI
	
;ADDED IN rev1
ORG 001BH
	;DISPLAY UPDATE
	;TIMER 1 OVERFLOW OCCURS HERE
	;THIS ROUTINE IS USED FOR UPDATING THE DISPLAY

	;0x54 IS THE 8 BIT COUNTER
	;0x39 HAS THE ADDRESS OFFSET OF THE PARTICULAR CHARACTER [UNIT 1 DISP]
	;0x3A HAS THE ADDRESS OFFSET OF THE PARTICULAR CHARACTER [UNIT 2 DISP]
	
	CLR TR1
	
	MOV 0x3E, 0x01; BACKUP R1 POINTER
	
	MOV 0x01, 0x3C; RESTORE R1 POINTER
	
	;-------------- LOGIC STARTS HERE -------------
	JB 0x25.0, STAGE_2_DISPLAY
	
	
	;---------- STAGE 1 -------------
	REPEAT_CYCLE:
	MOV R1, #0x7E
	
	CLR CLK
	SETB DAT
	SETB CLK
	
	REPEAT:

	MOV P0, @R1
	;---------- STAGE 1 END ----------
	
	SETB 0x25.0
	LJMP RETURN_FROM_DISPLAY_SUBR
	
	
	STAGE_2_DISPLAY:
	;----------- STAGE 2 -------------
	MOV P0, #0xFF; CLEAR THE PORT
	CLR CLK
	CLR DAT
	SETB CLK
	DEC R1
	
	CJNE R1, #0x6E, CONT_CYCLE
	LJMP REPEAT_CYCLE
	
	CONT_CYCLE:
	SJMP REPEAT
	;---------- STAGE 2 ENDS -------
	
	
	
	;----------------------------------------------
	
	RETURN_FROM_DISPLAY_SUBR:
	MOV 0x3C, 0x01; BACKUP R1 POINTER
	
	MOV 0x01, 0x3E; RESTORE R1 POINTER
	
	MOV TL1, #0x00
	SETB TR1
	RETI
	

; MAIN PROGRAM STARTS HERE
ORG 100H
	START:
	;********** CLEAR THE RAM *****************
	;USING REGISTERS FROM 7FH TO 6FH
	MOV 0x07, #0x08;INIT THE COUNTER
	MOV R0,#0x7F; INIT THE POINTER
	REPEAT_RAM_CLEAR:
	MOV @R0, #0xFF;
	DEC R0
	CJNE R0, #0x6E, REPEAT_RAM_CLEAR
	
	;MOV 0x75, #0x00; MARK END BOUND
	
	;CLEAR THE PORT
	MOV P2, #0x00
	MOV P0, #0xFF
	
	CLR F0; CLEAR THE SCAN FLAG
	
	MOV 0x43, #0x00; CLEAR THE SCORE REGISTER
	
	;RAM CLEAR COMPLETE
	;********** RAM CLEAR COMPLETE ************
	
	;RESET 4026
	CLR CLR_SCORE
	SETB CLR_SCORE
	CLR CLR_SCORE
	
	CLR 0x26.7; CLEAR THE GAME RESTART FLAG
	
	;CLR 0x23.0; USE THE FIRST SCORING METHOD
	SETB 0x23.0; USE THE SECOND SCORING METHOD
	
	
	MOV 0x26, #0x00; CLEAR ALL THE FLAGS
	SETB IT0; FALLING EDGE INTERRUPT FOR INT0
	SETB IT1; FALLING EDGE INTERRUPT FOR INT1
	
	;********** CONFIGURE THE TIMER IN 16 BIT MODE ************
	MOV R5, #0x00; TIMER OVERFLOW COUNTER. CHECK IF 15 THEN 1 SEC ELAPSED
	MOV TMOD, #0x21; TIMER0 IN 16BIT MODE, TIMER 1 IN 8 BIT AUTORELOAD
	MOV IE, #0x8F; EABLE GLOBAL INTERRUPT, TIMER 0, TIMER 1 INTERRUPT AND INT0 INTERRUPT
	SETB TR0; RUN THE TIMER
	
;	--------- DEFINE TIMER0 FOR DISPLAY UPDATE --------
	;MOV TMOD, #0x21; TIMER 1 8 BIT AUTORELOAD, TIMER 0 IN 16 BIT MODE
	MOV TH1, #0x00
	MOV TL1, #0x00
	
	CLR 0x25.0
	;SETB EA
	;SETB ET1; TIMER 0 OVERFLOW INTERRUPT
	SETB TR1
	
	;MODIFIED IN rev1
;	;********** CONFIGURE SERIAL PORT *************************
;	;SERIAL RECEIVE DOESN'T WORK. IT CAN BE A BUG
;	MOV A, TMOD
;	ORL A, #0x20; TIMER1, MODE 2 AUTO RELOAD
;	MOV TMOD, A
;	MOV TH1, #0xFD; 9600 BAUD RATE
;	MOV SCON, #0x50; 8 BIT UART, REN ENABLED
;	SETB TR1; TURN ON THE TIMER (SERIAL COMM ENABLED)

;	CONFIGURE SERIAL PORT
	;SETUP SERIAL COMM FOR DISPLAYING THE DATA
	MOV SCON, #0x40; MODE 1 VARIABLE BAUD RATE
	;TIMER 2 FOR GENERATING BAUD RATE
	;CRYSTAL FREQ: 11.0592 MHZ
	;CALCULATED RCAP2H & RCAP2L VALUES FOR 9600 BAUD RATE IS 1996
	MOV 0xCB, #0xFF; RCAP2H
	MOV 0xCA, #0xDC; RCAP2L
	MOV 0xC8, #0x10; T2CON	
	
	
	LJMP DISPLAY


ORG 150H
	;DELAY FOR MULTIPLEXING
	DELAY:
	MOV R6, #255D
	WAIT: DJNZ R6, WAIT
	RET

ORG 165H
	DISPLAY:
	SETB EA; ENABLE INTERRUPS
	CLR 0x26.4
	
	;MODIFIED IN rev1
;	;USING REGISTERS FROM 7EH TO 75H
;	MOV R0, #0x7E;INIT THE POINTER
;;	MOV A, #0x01; INIT THE SCAN ROW POINTER

;	;INITIALLY SEND 1
;	CLR CLK
;	SETB DAT
;	SETB CLK

	INFINITE_DISP:
	;MODIFIED IN rev1
;	MOV P0, @R0
;	LCALL DELAY
;	MOV P0, #0xFF; CLEAR THE PORT
;	CLR CLK
;	CLR DAT
;	SETB CLK
;	DEC R0

	;#########################################
	JNB RI, RESTART_CHECK
	;RECEIVED DATA SERIALLY.
	;I AM NOT SURE BUT THIS DOES NOT WORK
	;IF RI IS SET, THE DATA IS RECEIVED. READ SBUF AND DECODE THE ACTION TO PERFORM
	MOV A, SBUF
	CLR RI; CLEAR FLAG
	MOV P1, #0x00; FOR TESTING TO SEE IF SERIAL RECEIVE WORKS. IF RECEIVE SUCCESSFUL PORT 1 IS MODE LOW
	;#########################################
	
	RESTART_CHECK:
	;CHECK IF RESTART BUTTON TRIGGERED
	JNB 0x26.7, CHECK_SWITCH_STATE
	LJMP START; RESTART THE GAME
	
	CHECK_SWITCH_STATE:
	JNB 0x26.5, RESUME_TASK
	CLR 0x26.5;CLEAR THE FLAG
	
	;SWITCH STATE CHANGED. GET THE CHANGED STATE
	;--- CHECK THE STATE OF THE BUTTONS -----
	;SEND START CONDITION
	   LCALL STARTC
	   
	;SEND SLAVE ADDRESS
	   MOV A,#0x71 ;PCF8574 ADDRESS WITH READ MODE
	   LCALL SEND
	   
	;RECEIVE DATA
	   LCALL RECV
	   LCALL ACK
	
	;STOP CONDITION
	   LCALL STOP
	   
	;DECODE WHICH BUTTON WAS CLICKED
	;	P7	P6	P5	P4	P3	P2	P1	P0
	;			   DOWN  L  R  ACLK CLK
		
		CPL A; COMPLEMENT A
		MOV 0x34, A; TEMPORARILY STORE CURRENT BUTTON STATE
		XRL A, 0x35; XOR CURRENT BUTTON STATE AND OLD BUTTON STATE
		
		MOV 0x36, A; STORE XOR RESULT IN TEMP REGISTER
		
		ANL A, 0x34; SWITCH OPEN-CLOSE-OPEN will cause INC/DEC by 1
		
	MOV 0x27, A
	
	JNB 0x27.0, CHECK_NEXT_BTN0
	;CLOCKWISE
	SETB 0x26.2; CLK FLAG SET
	LCALL CLK_MOVEMENT
	CLR 0x26.2; CLEAR THE FLAG
	SJMP DONE_BTN_MOVEMENT
	
	CHECK_NEXT_BTN0:
	JNB 0x27.1, CHECK_NEXT_BTN1
	;ANTI CLOCKWISE
	SETB 0x26.3; ANTICLK FLAG SET
	LCALL CLK_MOVEMENT
	CLR 0x26.3; CLEAR THE FLAG
	SJMP DONE_BTN_MOVEMENT
	
	CHECK_NEXT_BTN1:
	JNB 0x27.2, CHECK_NEXT_BTN2
	;RIGHT
	LCALL RIGHT_MOVEMENT
	SJMP DONE_BTN_MOVEMENT
	
	CHECK_NEXT_BTN2:
	JNB 0x27.3, CHECK_NEXT_BTN3
	;LEFT
	LCALL LEFT_MOVEMENT
	SJMP DONE_BTN_MOVEMENT
	
	CHECK_NEXT_BTN3:
	JNB 0x27.4, DONE_BTN_MOVEMENT
	;INCREASE FALL SPEED OF SHAPES
	SETB 0x26.6
	SJMP DONE_BTN_MOVEMENT		
	   
	DONE_BTN_MOVEMENT:
	;MOVE CURRENT BUTTON STATE TO 0x35
	MOV 0x35, 0x34;
	LJMP DISPLAY
	
	;#############################
	RESUME_TASK:
	;CJNE R0, #0x6E, INFINITE_DISP ;MODIFIED IN rev1
	;CJNE R5, #0x08, DISPLAY
	
	JB 0x26.6, HIGH_SPEED
	CLR C
	MOV A, #0x08; SET LOW SPEED HERE
	SUBB A, R5; SUBTRACT
	JNC GO_BACK_DISP
	SJMP SKIP_SPEED_CHK
	
	HIGH_SPEED:
;;	CJNE R5, #0x01, GO_BACK_DISP
	CLR C
	MOV A, #0x00; SET HIGH SPEED HERE
	SUBB A, R5; SUBTRACT
	JNC GO_BACK_DISP
	
	SJMP SKIP_SPEED_CHK
;	
	GO_BACK_DISP: LJMP DISPLAY
;	
	SKIP_SPEED_CHK:
	CLR EA; DISABLE ALL INTERRUPTS
	;CHECK IF THE F0 FLAG IS SET OR NOT. IF IT IS SET, GO TO DOWN_MOVEMENT ELSE PUT A NEW SHAPE IN 7F,7E,7D
	JB F0, DOWN_MOVEMENT; F0 IS SET. CONTINUE SCANNING THE DISPLAY
	;F0 IS CLEARED. INTRODUCE A NEW SHAPE
	MOV A, TL0; FOR GETTING RANDOM SHAPE
	ANL A, #0x07; MASK. 8 SHAPES CAN BE DEFINED
	
;	SHAPES STORED IN LOCATIONS 0x28, 0x29, 0x2A
	LCALL GET_SHAPE; WITH RANDOM NUM IN A
	;A HAS THE ADDRESS OF THE SHAPE
	;BACKUP THE ADDRESS IN A REGISTER
	MOV R6, A
	LCALL GET_SHAPE
	;USING LOC 28H TO 2AH FOR BACKING UP CURRENT SHAPE
	MOV 0x28, A
	LCALL CALC_SCORE; COUNT NUM OF ZEROS
	INC R6
	MOV A, R6
	LCALL GET_SHAPE
	MOV 0x29, A
	LCALL CALC_SCORE; COUNT NUM OF ZEROS
	INC R6
	MOV A, R6
	LCALL GET_SHAPE
	MOV 0x2A, A
	LCALL CALC_SCORE; COUNT NUM OF ZEROS
	
;WRITE TO THE RAM
	MOV 0x7F, 0x28;
	MOV 0x7E, 0x29;
	MOV 0x7D, 0x2A

	
;	;USING LOC 34H TO 36H FOR BACKING UP CURRENT SHAPE
;	MOV 0x28, #0xFB
;	MOV 0x29, #0xE3
;	MOV 0x2A, #0xFF
	
	MOV SHP_SRT_LOC, #0x7F; INDICATES WHERE THE CURRENT SHAPE STARTS
	MOV SHP_BIT_LOC, #0x03; INDICATES THE MIDDLE BIT POSITION OF CURRENT SHAPE
	
	SETB F0
	
	;CONTINUE WITH DOWN MOVEMENT
	
	DOWN_MOVEMENT:
	;MOVE THE SHAPE DOWN
	MOV R5, #0x00; RESET OVERFLOW COUNTER
	;------------------------------------
	
	;COUNT TOTAL 0s IN SHP_STR_LOC {0 TO 3}
	;BACK UP THE LOCATIONS SHP_STR_LOC {0 TO 3}
	;THEN REMOVE THE CURRENT PATTERN BY ANL AND XRL
	;AFTER THAT ANL THE CURRENT PATTERN AT SHP_SRT_LOC {1 TO 3}
	;NOW COUNT THE NUMBER OF 0s IN SHP_STR_LOC {0 TO 3}
	;IF THE COUNT IS SAME, CONTINUE ELSE CANCEL AND RESTORE THE BACKUP
	
	LCALL PARTA
	
	
	;ADD THE PATTERN TO THE NEW LINE
	MOV R0, SHP_SRT_LOC
	DEC R0
	
	MOV A, 0x28
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x29
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x2A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	LCALL PARTB
	
	;ADDED IN rev1
;	JB 0x26.6, SKIP_SERIAL_STATE_SEND
;	MOV A, 0x44
;	JNZ CONT_WITHOUT_SENDING_STATE
;	MOV 0x44, #0x04; COUNT 4
;	ACALL SEND_SERIAL_STATE
;	
;	CONT_WITHOUT_SENDING_STATE:
;	DEC 0x44
;	
;	SKIP_SERIAL_STATE_SEND:
	JNB 0x26.4, RESUME_AGAIN
	CLR F0; CLEAR THE SCAN FLAG
	CLR 0x26.6; CLEAR HIGH SPEED
	
	JNB 0x23.0, SERIAL_SCORE
	;CALCULATE THE SCORE USING SECOND METHOD
	LCALL CALC_SCORE2
	
	SERIAL_SCORE:
	;rev1: SEND THE GAME STATE TO EEPROM
		;	MOV SBUF, 0x43; SHOWS THE CURRENT SCORE IN THE TERMINAL
		;	WAIT_FOR_TRANS: JNB TI, WAIT_FOR_TRANS
		;	CLR TI
		;ACALL SEND_SERIAL_STATE
	
	RESUME_AGAIN:
	DEC SHP_SRT_LOC
	LJMP DISPLAY
	
;ADDED IN rev1
;SEND_SERIAL_STATE:
;			
;			MOV 0x40, R0; BACKUP R1
;			MOV R0, #0x7E
;			MOV 0x42, #16; COUNTER
;			
;			SETB 0xC8.2; START THE TIMER 2			
;			
;			REPEAT_STATE_SEND1:
;			MOV 0x41, #8; COUNTER
;			
;			MOV A, @R0
;			
;			REPEAT_STATE_SEND:
;			;CLR EA; CARRY SHOULD NOT BE SET
;			CLR C
;			RLC A
;			JNC SEND_0_STATE_SERIAL
;			
;			;TO REMOVE DISPLAY FLUCTUATIONS
;			SETB EA
;			CLR EA
;			
;			;SEND 1
;			MOV SBUF, #0x30; SEND THE GAME STATE (0)
;			WAIT_FOR_TRANS: JNB TI, WAIT_FOR_TRANS
;			CLR TI
;			SJMP DONE_SEND_CURRENT
;			
;			SEND_0_STATE_SERIAL:
;			MOV SBUF, #0x31; SEND THE GAME STATE (0)
;			WAIT_FOR_TRANS2: JNB TI, WAIT_FOR_TRANS2
;			CLR TI
;			
;			DONE_SEND_CURRENT:
;			DJNZ 0x41, REPEAT_STATE_SEND
;			
;			;SEND A NEW LINE CHARACTER
;			MOV SBUF, #0x0D; CR
;			WAIT_FOR_TRANS1: JNB TI, WAIT_FOR_TRANS1
;			CLR TI
;			
;			DEC R0
;			DJNZ 0x42, REPEAT_STATE_SEND1
;			
;			;SEND A NEW LINE CHARACTER
;			MOV SBUF, #0x0D; CR
;			WAIT_FOR_TRANS_PART: JNB TI, WAIT_FOR_TRANS_PART
;			CLR TI
;			
;			
;;			;NOW SEND A PARTITION
;;			MOV 0x41, #8; COUNTER
;;			
;;			REPEAT_SEND_PARTITION:
;;			MOV SBUF, #0x2D; SEND DASH
;;			WAIT_FOR_TRANS_PART: JNB TI, WAIT_FOR_TRANS_PART
;;			CLR TI
;;			DJNZ 0x41, REPEAT_SEND_PARTITION
;;			
;;;			;SEND A NEW LINE CHARACTER
;;			MOV SBUF, #0x0D; CR
;;			WAIT_FOR_TRANS_PART1: JNB TI, WAIT_FOR_TRANS_PART1
;;			CLR TI
;			
;			MOV R0, 0x40; RESTORE R0
;			CLR 0xC8.2; STOP THE TIMER 2
;			
;			
;			RET
			



ORG 2A0H
	;COUNT THE ZEROS IN A AND STORE IN 0x43 SCORE REGISTER
	CALC_SCORE:
	
	JB 0x23.0, SKIP_FIRST_METH; USING SECOND METHOD. SKIP THE FIRST METHOD
	
	MOV R7, #0x08
	
	CHECK_ZEROS:
	RLC A
	JC SKIP_SCORE_INC
	INC 0x43
	CLR DISP_CLK
	SETB DISP_CLK
	SKIP_SCORE_INC:
	DJNZ R7, CHECK_ZEROS
	
	SKIP_FIRST_METH:
	RET

ORG 300H
	;FOR COUNTING 0s AND STORE IN R2
	COUNT_ZERO:
	MOV R0, SHP_SRT_LOC
	MOV R2, #0x00;0 COUNTER
	
	MOV R6, #0x04
	
	REPEAT_AGAIN:
	MOV A, @R0
	MOV R7, #0x08
	
	REPEAT_COUNT:
	RLC A
	JC SKIP_INC
	INC R2
	SKIP_INC:
	DJNZ R7, REPEAT_COUNT
	
	DEC R0
	DJNZ R6, REPEAT_AGAIN
	RET
	
ORG 320H
	;FOR LEFT MANIPULATION
	LEFT_MOVEMENT:
	
	LCALL PARTA
	

	;ADD THE PATTERN 
	MOV R0, SHP_SRT_LOC
	
	MOV A, 0x28
	SETB C
	RLC A
	MOV 0x28, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x29
	SETB C
	RLC A	
	MOV 0x29, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x2A
	SETB C
	RLC A
	MOV 0x2A, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	

	LCALL PARTB
	JB 0x26.4, NEXT_CMD_CONT
	INC SHP_BIT_LOC
	
	NEXT_CMD_CONT:
	RET
	
	
ORG 355H
	RIGHT_MOVEMENT:
	LCALL PARTA
	

	;ADD THE PATTERN 
	MOV R0, SHP_SRT_LOC
	
	MOV A, 0x28
	SETB C
	RRC A
	MOV 0x28, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x29
	SETB C
	RRC A
	MOV 0x29, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x2A
	SETB C
	RRC A
	MOV 0x2A, A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	

	LCALL PARTB
	JB 0x26.4, NEXT_CMD_CONT1
	DEC SHP_BIT_LOC
	
	NEXT_CMD_CONT1:
	RET

	
ORG 395H
	CLK_MOVEMENT:
	;DO TRANSPOSE
	;CURRENT SHAPE IN REG 28H, 29H, 2AH
	;NEW SHAPE IN REG 2BH, 2CH, 2DH
	
	LCALL PARTA
	
	;ROTATE THE SHAPE REG TO START
	MOV R7, SHP_BIT_LOC
	DEC R7
	
	REPEAT_SHIFT:
	CLR C
	MOV A, 0x28
	RRC A
	MOV 0x28, A
	
	CLR C
	MOV A, 0x29
	RRC A
	MOV 0x29, A
	
	CLR C
	MOV A, 0x2A
	RRC A
	MOV 0x2A, A
	
	DJNZ R7, REPEAT_SHIFT
	
	;SHIFT COMPLETE
	
	;CLEAR
	MOV 0x20, #0xFF
	MOV 0x21, #0xFF
	MOV 0x22, #0xFF
	
	JNB 0x26.2, ANTI_CLK
	LCALL TEMP_CLK
	SJMP RESUME_TRANSPOSE
	
	ANTI_CLK:
	LCALL TEMP_ANTICLK
	
	RESUME_TRANSPOSE:
	;ROTATE THE SHAPE REG TO ORIGINAL LOC
	MOV R7, SHP_BIT_LOC
	DEC R7
	
	REPEAT_SHIFT1:
	
	MOV A, 0x20
	RL A
	MOV 0x20, A
	
	MOV A, 0x21
	RL A
	MOV 0x21, A
	
	MOV A, 0x22
	RL A
	MOV 0x22, A
	
	DJNZ R7, REPEAT_SHIFT1
	
	MOV 0x28, 0x20
	MOV 0x29, 0x21
	MOV 0x2A, 0x22

	;ADD THE PATTERN 
	MOV R0, SHP_SRT_LOC
	
	MOV A, 0x28
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x29
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	
	DEC R0
	MOV A, 0x2A
	ANL A, @R0;PATTERN ADDED TO NEW LINE
	MOV @R0, A
	

	LCALL PARTB

	RET
	
ORG 470H
	TEMP_ANTICLK:
	
	;------- ROW 0 -----------
	JB 0x28.0, SKIPP1
	CLR 0x20.2
	
	SKIPP1:
	JB 0x28.1, SKIPP2
	CLR 0x21.2
	
	SKIPP2:
	JB 0x28.2, SKIPP3
	CLR 0x22.2
	;----- COMPLETE ----------
	
	SKIPP3:
	;------ ROW 1 ---------
	JB 0x29.0, SKIPP4
	CLR 0x20.1
	
	SKIPP4:
	JB 0x29.1, SKIPP5
	CLR 0x21.1
	
	SKIPP5:
	JB 0x29.2, SKIPP6
	CLR 0x22.1
	;----- COMPLETE ----------
	
	SKIPP6:
	;------ ROW 2 ---------
	JB 0x2A.0, SKIPP7
	CLR 0x20.0
	
	SKIPP7:
	JB 0x2A.1, SKIPP8
	CLR 0x21.0
	
	SKIPP8:
	JB 0x2A.2, SKIPP9
	CLR 0x22.0
	;----- COMPLETE ----------
	
	SKIPP9:

	RET
	
ORG 510H
	TEMP_CLK:
	;------- ROW 0 -----------
	JB 0x28.0, SKIPP10
	CLR 0x22.0
	
	SKIPP10:
	JB 0x28.1, SKIPP11
	CLR 0x21.0
	
	SKIPP11:
	JB 0x28.2, SKIPP12
	CLR 0x20.0
	;----- COMPLETE ----------
	
	SKIPP12:
	;------ ROW 1 ---------
	JB 0x29.0, SKIPP13
	CLR 0x22.1
	
	SKIPP13:
	JB 0x29.1, SKIPP14
	CLR 0x21.1
	
	SKIPP14:
	JB 0x29.2, SKIPP15
	CLR 0x20.1
	;----- COMPLETE ----------
	
	SKIPP15:
	;------ ROW 2 ---------
	JB 0x2A.0, SKIPP16
	CLR 0x22.2
	
	SKIPP16:
	JB 0x2A.1, SKIPP17
	CLR 0x21.2
	
	SKIPP17:
	JB 0x2A.2, SKIPP18
	CLR 0x20.2
	;----- COMPLETE ----------
	
	SKIPP18:
	RET


ORG 550H
	PARTA:
	;COUNT ALL THE 0s
	LCALL COUNT_ZERO
	MOV R0, SHP_SRT_LOC;
	
	;USING LOC 30H TO 33H FOR BACKING UP CURRENT RAM
	MOV 0x30, @R0
	DEC R0
	MOV 0x31, @R0
	DEC R0
	MOV 0x32, @R0
	DEC R0
	MOV 0x33, @R0
	
	;REMOVE THE CURRENT PATTERN
	MOV R0, SHP_SRT_LOC	
	
	MOV A, 0x28
	CPL A
	ORL A, @R0;PATTERN REMOVED FROM LINE 1
	MOV @R0, A
	
	DEC R0
	MOV A, 0x29
	CPL A
	ORL A, @R0;PATTERN REMOVED FROM LINE 2
	MOV @R0, A
	
	DEC R0
	MOV A, 0x2A
	CPL A
	ORL A, @R0;PATTERN REMOVED FROM LINE 3
	MOV @R0, A

	;BACKUP THE SHAPE PATTERN
	MOV 0x2B, 0x28
	MOV 0x2C, 0x29
	MOV 0x2D, 0x2A
	
	RET

ORG 600H
	PARTB:
	;CHECK IF THE COUNT IS SAME
	MOV COUNT_BACKUP, R2
	LCALL COUNT_ZERO
	MOV A, R2
	CJNE A,COUNT_BACKUP, CANCEL1

	;------------------------------------
	RET
	
	CANCEL1:
	SETB 0x26.4
	;CANCEL THE OPERATION
	MOV A, SHP_SRT_LOC
	MOV P1, A
	;CJNE A, #0x7F, RESUME1
	CLR C
	SUBB A, #0x7E; SUBTRACT
	JC RESUME1

	;GAME OVER
	;SHOW THE SCORE STORED IN 0x43
	;MOV P1, 0x43
	MOV IE, #0x04; ONLY ENABLE INT1
	SETB EA; ENABLE INTERRUPT
	WAIT_FOR_RESTART: JNB 0x26.7, WAIT_FOR_RESTART
	LJMP START
	
	
	RESUME1:
	MOV R0, SHP_SRT_LOC
	
	MOV @R0, 0x30
	DEC R0
	MOV @R0, 0x31
	DEC R0
	MOV @R0, 0x32
	DEC R0
	MOV @R0, 0x33

	MOV 0x28, 0x2B
	MOV 0x29, 0x2C
	MOV 0x2A, 0x2D
	
	RET
	
;######################## I2C COMMANDS ###########################

;****************************************
;START CONDITION FOR I2C COMMUNICATION
;****************************************

ORG 0680H
STARTC:
	SETB SCL
	CLR SDA
	CLR SCL
	RET
 
 
;*****************************************
;STOP CONDITION FOR I2C BUS
;*****************************************

ORG 0700H
STOP:
	CLR SCL
	CLR SDA
	SETB SCL
	SETB SDA
	RET
	
;*****************************************
;SENDING DATA TO SLAVE ON I2C BUS
;*****************************************

ORG 0730H
SEND:
	MOV R7,#08
BACK:
	CLR SCL
	RLC A
	MOV SDA,C
	SETB SCL
	DJNZ R7,BACK
	CLR SCL
	SETB SDA
	SETB SCL
	MOV C, SDA
	CLR SCL
	
	RET
 
 
;*****************************************
;ACK AND NAK FOR I2C BUS
;*****************************************

ORG 0750H
ACK:
	CLR SDA
	SETB SCL
	CLR SCL
	SETB SDA
	RET
 
ORG 0770H
NAK:
	SETB SDA
	SETB SCL
	CLR SCL
	SETB SCL
	RET
 
 
;*****************************************
;RECEIVING DATA FROM SLAVE ON I2C BUS
;*****************************************

ORG 0780H
RECV:
	MOV R7,#08
BACK2:
	CLR SCL
	SETB SCL
	MOV C,SDA
	RLC A
	DJNZ R7,BACK2
	CLR SCL
	
	RET
	
	
;============= SHAPES DEFINED HERE ===========
ORG 7A0H
	;TO ACCESS THIS DATA, USE MOVC A, @A + PC
	;8 SHAPES DEFINED HERE
	GET_SHAPE:
	INC A; GET AROUND RET
	MOVC A, @A + PC
	RET
	
ORG 7A3H
	DB 0x08;SHAPE 1 ADR OFFST [ADDR 0]
	DB 0x0B;SHAPE 2 ADR OFFST [ADDR 1]
	DB 0x0E;SHAPE 3 ADR OFFST [ADDR 2]
	DB 0x11;SHAPE 4 ADR OFFST [ADDR 3]
	DB 0x14;SHAPE 5 ADR OFFST [ADDR 4]
	DB 0x17;SHAPE 6 ADR OFFST [ADDR 5]
	DB 0x1A;SHAPE 7 ADR OFFST [ADDR 6]
	DB 0x1D;SHAPE 8 ADR OFFST [ADDR 7]
	
;	    __
;	 __|03|__
;	|04|03|02|
	DB 0xF7; [ADDR 8]
	DB 0xE3; [ADDR 9]
	DB 0xFF; [ADDR A]
;          __
;    __ __|02|
;   |04|03|02|
	DB 0xFB; [ADDR B]
	DB 0xE3; [ADDR C]
	DB 0xFF; [ADDR D]
;          __
;   |04|__|02|
;   |04|03|02|
	DB 0xEB; [ADDR E]
	DB 0xE3; [ADDR F]
	DB 0xFF; [ADDR 10]
;          __
;    __|03|02|
;   |04|03|02|
	DB 0xF3; [ADDR 11]
	DB 0xE3; [ADDR 12]
	DB 0xFF; [ADDR 13]
;       __ __
;      |03|02|
;      |03|02|
	DB 0xF3; [ADDR 14]
	DB 0xF3; [ADDR 15]
	DB 0xFF; [ADDR 16]
;          __
;    __ __|02|
;   |04|03|02|
;	      |02|
	DB 0xFB; [ADDR 17]
	DB 0xE3; [ADDR 18]
	DB 0xFB; [ADDR 19]
;    __
;   |04|
;	|04|__
;	|04|03|
	DB 0xEF; [ADDR 1A]
	DB 0xEF; [ADDR 1B]
	DB 0xE7; [ADDR 1C]
;    __ __ __
;   |04|03|02|
	DB 0xFF; [ADDR 1D]
	DB 0xE3; [ADDR 1E]
	DB 0xFF; [ADDR 1F]
		
ORG 7D0H
	;SECOND SCORING METHOD
	CALC_SCORE2:
	;MOVE THROUGH EACH ROW. IF A ROW IS 0x00, INC THE SCORE BY ONE AND MOVE ALL THE ABOVE ROWS DOWN
	;ROW STARTS FROM 0x6F AND GOES TILL 0x7F
	MOV R1, #0x6E; INIT THE POINTER
	
	ROW_SCORE_CHECK:
	INC R1;
	CJNE R1, #0x7E, CONT_SCANNING_SCORE; LAST GAME RAM
	SJMP SCORE_CHECK_OVER
	
	CONT_SCANNING_SCORE:
	CJNE @R1, #0x00, ROW_SCORE_CHECK; ROW IS FILLED.
	;ROW FILLED FOUND.
	;INC THE SCORE BY 1
	INC 0x43
	CLR DISP_CLK
	SETB DISP_CLK
	
	MOV A, R1
	MOV R0, A
	INC R0
	
	MOV 0x7F, #0xFF; CLEAR THE TOP REGISTER
	
	;MOVE DOWN ALL THE ROWS
	REPEAT_ROW_DOWN:
	MOV A, @R0
	MOV @R1, A
	INC R0
	INC R1
	CJNE R1, #0x7F, REPEAT_ROW_DOWN
	
	;SCORE CHECK DOWN. REPEAT
	SJMP CALC_SCORE2
	
	
	SCORE_CHECK_OVER:
	RET
END